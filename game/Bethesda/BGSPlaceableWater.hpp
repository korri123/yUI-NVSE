#pragma once
\
#include "TESBoundObject.hpp"
#include "TESModel.hpp"

class TESWaterForm;

// 0x50
class BGSPlaceableWater : public TESBoundObject {
public:
	enum EnumFlags : UInt32 {
		kWtrFlag_Reflects				= 1 << 0,
		kWtrFlag_ReflectsActors			= 1 << 1,
		kWtrFlag_ReflectsLand			= 1 << 2,
		kWtrFlag_ReflectsLODLand		= 1 << 3,
		kWtrFlag_ReflectsLODBuildings	= 1 << 4,
		kWtrFlag_ReflectsLODTrees		= 1 << 5,
		kWtrFlag_ReflectsSky			= 1 << 6,
		kWtrFlag_ReflectsDynamicObjects = 1 << 7,
		kWtrFlag_ReflectsDeadBodies		= 1 << 8,
		kWtrFlag_Refracts				= 1 << 9,
		kWtrFlag_RefractsActors			= 1 << 10,
		kWtrFlag_RefractsLand			= 1 << 11,
		kWtrFlag_RefractsDynamicObjects	= 1 << 16,
		kWtrFlag_RefractsDeadBodies		= 1 << 17,
		kWtrFlag_SilhouetteReflections	= 1 << 18,
		kWtrFlag_Unk8000000				= 1 << 27,
		kWtrFlag_Depth					= 1 << 28,
		kWtrFlag_ObjectTextureCoords	= 1 << 29,
		kWtrFlag_AutoGenerated			= 1 << 30,
		kWtrFlag_NoUnderwaterFog		= 1 << 31,
	};

	TESModel		model;
	EnumFlags		eFlags;
	TESWaterForm*	pWaterType;

	static BGSPlaceableWater* CreateObject();


	// this is not serious, a function for every flag? :pepeglare:
	// Reflections

	bool HasReflection() const { return eFlags & kWtrFlag_Reflects; }
	void SetReflects(bool abSet) { eFlags = abSet ? (EnumFlags) (eFlags | kWtrFlag_Reflects) : (EnumFlags) (eFlags & ~kWtrFlag_Reflects); }

	bool HasActorReflection() const { return eFlags & kWtrFlag_ReflectsActors; }
	void SetReflectsActors(bool abSet) { eFlags = abSet ? (EnumFlags) (eFlags | kWtrFlag_ReflectsActors) : (EnumFlags) (eFlags & ~kWtrFlag_ReflectsActors); }

	bool HasLandReflection() const { return eFlags & kWtrFlag_ReflectsLand; }
	void SetReflectsLand(bool abSet) { eFlags = abSet ? (EnumFlags) (eFlags | kWtrFlag_ReflectsLand) : (EnumFlags) (eFlags & ~kWtrFlag_ReflectsLand); }

	bool HasSkyReflection() const { return eFlags & kWtrFlag_ReflectsSky; }
	void SetReflectsSky(bool abSet) { eFlags = abSet ? (EnumFlags) (eFlags | kWtrFlag_ReflectsSky) : (EnumFlags) (eFlags & ~kWtrFlag_ReflectsSky); }

	bool HasLODLandReflection() const { return eFlags & kWtrFlag_ReflectsLODLand; }
	void SetReflectsLODLand(bool abSet) { eFlags = abSet ? (EnumFlags) (eFlags | kWtrFlag_ReflectsLODLand) : (EnumFlags) (eFlags & ~kWtrFlag_ReflectsLODLand); }

	bool HasLODBuildingReflection() const { return eFlags & kWtrFlag_ReflectsLODBuildings; }
	void SetReflectsLODBuildings(bool abSet) { eFlags = abSet ? (EnumFlags) (eFlags | kWtrFlag_ReflectsLODBuildings) : (EnumFlags) (eFlags & ~kWtrFlag_ReflectsLODBuildings); }

	bool HasLODTreeReflection() const { return eFlags & kWtrFlag_ReflectsLODTrees; }
	void SetReflectsLODTrees(bool abSet) { eFlags = abSet ? (EnumFlags) (eFlags | kWtrFlag_ReflectsLODTrees) : (EnumFlags) (eFlags & ~kWtrFlag_ReflectsLODTrees); }

	bool HasLODReflection() const {
		return HasLODLandReflection() || HasLODBuildingReflection() || HasLODTreeReflection();
	}

	void SetLODReflection(bool abSet) {
		SetReflectsLODLand(abSet);
		SetReflectsLODBuildings(abSet);
		SetReflectsLODTrees(abSet);
	}

	bool ReflectsDynamicObjects() const { return eFlags & kWtrFlag_ReflectsDynamicObjects; }
	void SetReflectsDynamicObjects(bool abSet) { eFlags = abSet ? (EnumFlags) (eFlags | kWtrFlag_ReflectsDynamicObjects) : (EnumFlags) (eFlags & ~kWtrFlag_ReflectsDynamicObjects); }

	bool ReflectsDeadBodies() const { return eFlags & kWtrFlag_ReflectsDeadBodies; }
	void SetReflectsDeadBodies(bool abSet) { eFlags = abSet ? (EnumFlags) (eFlags | kWtrFlag_ReflectsDeadBodies) : (EnumFlags) (eFlags & ~kWtrFlag_ReflectsDeadBodies); }

	bool GetUnk8000000() const { return eFlags & kWtrFlag_Unk8000000; }
	void SetUnk8000000(bool abSet) { eFlags = abSet ? (EnumFlags) (eFlags | kWtrFlag_Unk8000000) : (EnumFlags) (eFlags & ~kWtrFlag_Unk8000000); }
	
	bool HasRefraction() const { return eFlags & kWtrFlag_Refracts; }
	void SetRefracts(bool abSet) { eFlags = abSet ? (EnumFlags) (eFlags | kWtrFlag_Refracts) : (EnumFlags) (eFlags & ~kWtrFlag_Refracts); }

	bool HasActorRefraction() const { return eFlags & kWtrFlag_RefractsActors; }
	void SetRefractsActors(bool abSet) { eFlags = abSet ? (EnumFlags) (eFlags | kWtrFlag_RefractsActors) : (EnumFlags) (eFlags & ~kWtrFlag_RefractsActors); }

	bool HasLandRefraction() const { return eFlags & kWtrFlag_RefractsLand; }
	void SetRefractsLand(bool abSet) { eFlags = abSet ? (EnumFlags) (eFlags | kWtrFlag_RefractsLand) : (EnumFlags) (eFlags & ~kWtrFlag_RefractsLand); }

	bool HasSilhouetteReflections() const { return eFlags & kWtrFlag_SilhouetteReflections; }
	void SetSilhouetteReflections(bool abSet) { eFlags = abSet ? (EnumFlags) (eFlags | kWtrFlag_SilhouetteReflections) : (EnumFlags) (eFlags & ~kWtrFlag_SilhouetteReflections); }

	bool HasDepth() const { return eFlags & kWtrFlag_Depth; }
	void SetDepth(bool abSet) { eFlags = abSet ? (EnumFlags) (eFlags | kWtrFlag_Depth) : (EnumFlags) (eFlags & ~kWtrFlag_Depth); }

	bool IsProceduralWater() const { return eFlags & kWtrFlag_AutoGenerated; }
	void SetProceduralWater(bool abSet) { eFlags = abSet ? (EnumFlags) (eFlags | kWtrFlag_AutoGenerated) : (EnumFlags) (eFlags & ~kWtrFlag_AutoGenerated); }

	void SetWaterType(TESWaterForm* apWaterType) { pWaterType = apWaterType; }
};
static_assert(sizeof(BGSPlaceableWater) == 0x50);